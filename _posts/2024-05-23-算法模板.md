[TOC]

# 排序

## 快速排序

1. 确定分界点x

    - `q[l]`,`q[r]`,`q[mid]`,随机

2. 调整区间，使得x左边的数都$\le x$，其右边的数都$\ge x$

3. 递归处理左右两段

    - 先以x为界分成两个数组a和b

    - 若小于等于x，放在a中
    - 若大于等于x，放在b中
    - 最后合并a和b

```c++
#include<iostream>

using namespace std;
const int N = 1e6 + 10;

int q[N];

int n;

void quick_sort(int q[], int l, int r){
    if (l >= r) return;
    int x = q[(l + r + 1) / 2], i = l - 1, j = r + 1;
    while (i < j){
        do i++; while (q[i] < x);
        do j--; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, i - 1);
    quick_sort(q, i, r);
}

int main(){
    scanf("%d", &n);
    for (int i = 0; i < n; i++) scanf("%d", &q[i]);
    quick_sort(q, 0, n - 1);
    for (int i = 0; i < n; i++) printf("%d ", q[i]);
    return 0;
} 
```

- 快排是不稳定的



## 归并排序

1. 确定分界点：mid = (l+ r) / 2
2. 递归排序（左边和右边）
3. **归并**（将两个有序数组合并为一个有序数组）

```c++
#include<iostream>
using namespace std;
const int N = 1e6 + 10;

int n;
int q[N], tmp[N];

void merge_sort(q, l, r){
    if (l >= r) return;
    int mid = (l + r) / 2, i = l, j = mid + 1, k = 0;
    // 递归处理左右
    merge_sort(q, l, mid), merge_sort(q, mid + 1, r);
    // 归并
    while (i <= mid && j <= r){
        if (q[i] < q[j]) tmp[k++ ] = q[i++];
        else tmp[k++] = q[j++];
    }
    while (i <= mid){
        tmp[k ++] = q[i++];
    }
    while (j <= r){
        tmp[k++] = q[j++];
    }
    // 写回原数组
    for (int i = l, j = 0; i < r; i++, j++){
        q[i] = tmp[j]
    }
}

int main(){
	scanf("%d", &n);
    for (i = 0; i < n; i++) scanf("%d", &q[i]);
    merge_sort(q, 0, n - 1);
    for (i = 0; i < n; i++) printf("%d", q[i]);
    return 0;
}
```

- 归并排序是稳定的
- 算法复杂度为$O(nlogn)$

# 二分

## 整数二分

​	二分的本质是边界，即在某一个范围内定义一个性质，该性质在某个数左半边是满足的，在右半边时不满足的，我们要找的就是这个分界点。

​	但是整数二分要考虑这个边界其实是两个数，即左边区域的右边的点和右边区域左边的点不一致。这就对应两个模板。

-  如果我们要找的是右边界点

```c++
// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用
int bsearch(int l, int r){
    while (l < r){
        int mid = l + r + 1 >> 1;
        if check(mid) l = mid;
        else r = mid - 1;
    }
    return l;
}
```



- 如果我们要找的是左边界点

```c++
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用
int bsearch(int l, int r){
    while(l < r){
        int mid = l + r >> 1;
        if check(mid) r = mid;
        else l = mid + 1;
    }
    return l;
}
```





## 浮点数二分

``` c++
#include<iostream>
using namespace std;

int main(){
    double x;
    cin >> x;
    double l = -10000.0, r = 10000.0;
    while (r - l > 1e-8){
        double mid = (l + r) / 2;
        if (mid * mid * mid >= x){
            r = mid;
        } 
        else{
            l = mid;
        }
    }
    printf("%.6lf", l);
    return 0;
}
```

# 高精度

总体来说是把大数的每一位存在数组里。

​	低位存低位（即第0位存个位）

## 高精度加法

A + B

- len(A)(len(B)) = 1e6

 ```c++
 #include<iostream>
 #include<vector>
 using namespace std;
 
 vector<int> add(vector<int> A, vector<int> B){
     vector<int> C;
     int t = 0;
     for (int i = 0; i < A.size() || i < B.size(); i++){
         if (i < A.size()) t += A[i];
         if (i < B.size()) t += B[i];
         C.push_back(t % 10);
         t /= 10;
     }
     if (t) C.push_back(t);
     return C;
 }
 
 int main(){
     string a, b;
     cin >> a >> b;
     vector<int> A, B;
     for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0');
     for (int i = b.size() - 1; i >= 0; i--) B.push_back(b[i] - '0');
     auto C = add(A, B);
     for (int i = C.size() - 1; i >= 0; i--) printf("%d", C[i]);
     return 0;
 }
 ```





## 高精度减法

A - B

- len(A)(len(B)) = 1e6

```c++
#include<iostream>
#include<vector>
using namespace std;
bool cmp(vector<int> A, vector<int> B){
    if (A.size() != B.size()) return A.size() > B.size();
    for (int i = A.size() - 1; i >= 0; i--){
        if (A[i] != B[i]){
            return A[i] > B[i];
        }
    }
    return true;
}

vector<int> sub(vector<int> A, vector<int> B){
    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size(); i++){
        t = A[i] - t;
        if (i < B.size()) t -= B[i];
        C.push_back((t + 10) % 10);
        if (t < 0) t = 1;
        else t = 0;
    }
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}

int main(){
    string a, b;
    cin >> a >> b;
    vector<int> A, B;
    for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0');
    for (int i = b.size() - 1; i >= 0; i--) B.push_back(b[i] - '0');
    if (cmp(A, B)){
        auto C = sub(A, B);
        for (int i = C.size() - 1; i >= 0; i--) printf("%d", C[i]);
    }
    else{
        auto C = sub(B, A);
        printf("-");
        for (int i = C.size() - 1; i >= 0; i--) printf("%d", C[i]);
    }
}
```





## 高精度乘法

A * a

- len(A) $\le$1e6，a<1e9

```C++
#include<iostream>
#include<vector>
using namespace std;

vector<int> mul(vector<int> A, int b){
    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size(); i++){
        t += A[i] * b;
        C.push_back(t % 10);
        t /= 10;
    }
    if (t) C.push_back(t);
    return C;
}

int main(){
    string a;
    int b;
    vector<int> A;
    cin >> a >> b;
    for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0');
    auto C = mul(A, b);
    for (int i = C.size() - 1; i >= 1; i--)
        if (C[i] == 0) C.pop_back();
        else break;
    for (int i = C.size() - 1; i >= 0; i--) printf("%d", C[i]);
    return 0;
}
```



## 高精度除法

A / a

- len(A) $\le$1e6，a<1e9

```C++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

vector<int> devide(vector<int> &A, int b, int &r){
    r = 0;
    vector<int> C;
    for (int i = A.size() - 1; i >= 0; i--){
        r = r * 10 + A[i];
        C.push_back(r / b);
        r %= b;
    }
    reverse(C.begin(), C.end());
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}

int main(){
    string a;
    int b;
    cin >> a >> b;
    vector<int> A;
    for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0');
    int r;
    auto C = devide(A, b, r);
    for(int i = C.size() - 1; i >= 0; i--) printf("%d", C[i]);
    printf("\n%d", r);
    return 0;
}
```

# 前缀和

## 一维前缀和

- 原数组：$a_1, a_2, a_3, \cdots, a_n$
- 前缀和：$S_i = a_1 + a_2 + \cdots + a_i, S_0=0$

- 如何求$S_i$：$S_i = S_{i - 1}+a_i$
- 作用：当求[l, r]区间内的和时，可以以$O(1)$的时间复杂度求和。计算方法是$S_r - S_{l - 1}$

```c++
#include<iostream>
#include<cstdio>
using namespace std;
const int N = 1e5 + 10;
int q[N];

int main(){
    int n = 0, m = 0;
    scanf("%d%d", &n, &m);
    q[0] = 0;
    for (int i = 1; i <= n; i++){
        scanf("%d", &q[i]);
        q[i] = q[i - 1] + q[i];
    }
    int l = 0, r = 0;
    while (m--){
        scanf("%d%d", &l, &r);
        printf("%d\n", q[r] - q[l - 1]);
    }
}
```

## 二维前缀和

   ![20201217174700577.png](https://cdn.acwing.com/media/article/image/2023/04/04/29688_c9a2bee0d2-20201217174700577.png)

- 每个矩形面积都代表了它所包含的元素的和。

![20201216215336857.png](https://cdn.acwing.com/media/article/image/2023/04/04/29688_d9329a0dd2-20201216215336857.png)

- 可以得到$S[i, j]=S[i-1, j] + S[i, j - 1] - S[i-1, j-1] + a[i, j]$

![2020121717473287.png](https://cdn.acwing.com/media/article/image/2023/04/04/29688_e76d64f1d2-2020121717473287.png)

![20201217170800381.png](https://cdn.acwing.com/media/article/image/2023/04/04/29688_f973f889d2-20201217170800381.png)

$s[x2, y2] - s[x1 - 1, y2] - s[x2, y1 - 1] + s[x1 - 1, y1 - 1]$

![20201217174751639.png](https://cdn.acwing.com/media/article/image/2023/04/04/29688_067abec1d2-20201217174751639.png)

```C++
#include<iostream>
using namespace std;
const int N = 1010;
int num[N][N];

int main(){
    int n, m, q;
    cin >> n >> m >> q;
    for(int i = 1; i <= n ; i++){
        for(int j = 1; j <= m; j++){
            int x = 0;
            cin >> x;
            num[i][j] = num[i - 1][j] + num[i][j - 1] + x - num[i - 1][j - 1];
        }
    }
    int result = 0;
    while(q--){
        int x1, y1, x2, y2;
        cin >> x1 >> y1 >> x2 >> y2;
        result = num[x2][y2] - num[x1 - 1][y2] - num[x2][y1 - 1] + num[x1 - 1][y1- 1];
        cout << result <<endl;
    }
}
```

# 差分

## 一维差分

- 初始数组：$a_1, a_2, \cdots, a_n$

    需要构造：$b_1, b_2, \cdots, b_n$，使得$a_i=b_1 + b_2 + \cdots+b_i$.

    构造方式：$b_1 = a_1, b_i = a_i - a_{i-1}$

- 构造的作用：从$b$数组以$O(n)$的时间得到$a$。

    ​                 主要解决一种操作，以$O(1)$的复杂度在`[l,r]`中加上$c$​

    ​                 `b[l] + c; b[r+1] - c`

```c++
#include <iostream>

using namespace std;

const int N = 100010;
int n, m;
int a[N], b[N];

void insert(int l, int r, int c) {
    b[l] += c;
    b[r + 1] -= c;
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) scanf("%d", &a[i]);

    for (int i = 1; i <= n; i++) insert(i, i, a[i]);

    while (m--) {
        int l, r, c;
        scanf("%d%d%d", &l, &r, &c);
        insert(l, r, c);
    }  

    for (int i = 1; i <= n; i++) b[i] += b[i - 1];
    for (int i = 1; i <= n; i++) printf("%d ", b[i]);

    return 0;

}
```

## 二维差分

以图示为例，我们需要让中间的小正方形加上$c$

![20201217174836198.png](https://cdn.acwing.com/media/article/image/2023/04/04/29688_0cbaf7e5d2-20201217174836198.png)

那么我们需要做的工作如下：

![20201217170336254.png](https://cdn.acwing.com/media/article/image/2023/04/04/29688_1e2c1a36d2-20201217170336254.png)

![20201217172035975.png](https://cdn.acwing.com/media/article/image/2023/04/04/29688_2f34208bd2-20201217172035975.png)

```c++
#include<iostream>
using namespace std;

const int N = 1005;

int main()
{
    int n, m, q;
    cin >> n >> m >> q;
    int a[N][N];
    int b[N][N];
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= m; j++){
            cin >> a[i][j];
            b[i][j] = a[i][j] - a[i - 1][j] - a[i][j - 1] + a[i - 1][j - 1];
        }
    }
    while(q--){
        int x1, y1, x2, y2, c;
        cin >> x1 >> y1 >> x2 >> y2 >> c;
        b[x1][y1] += c;
        b[x1][y2 + 1] -= c;
        b[x2 + 1][y1] -= c;
        b[x2 + 1][y2 + 1] += c;
    }
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= m; j++){
            a[i][j] = b[i][j] + a[i - 1][j] + a[i][j - 1] - a[i - 1][j - 1];
            cout << a[i][j] << " ";
        }
        cout << endl;
    }
}
```

# 双指针

```c++
for(int i = 0, j = 0; i < n; i++){
    while(j < i && check(i, j)) j++;
    
    //每道题目的具体逻辑
}
```

作用是：应用某些性质，把两个for循环（从0到n），即$O(n^2)$的复杂度优化到$O(n)$

## 最长连续不重复子序列

```c++
#include<iostream>
using namespace std;
const int N = 100010;
int a[N], q[N];
int n;

int main(){
    scanf("%d", &n);
    for (int i = 0; i < n; i++) scanf("%d", &a[i]);
    int res = -1;
    for (int i = 0, j = 0; i < n; i++){
        q[a[i]]++;
        while(q[a[i]] > 1){
            q[a[j]]--;
            j++;
        }
        res = max(res, i - j + 1);
    }
    cout << res;
    return 0;
}
```

- 我们考虑双指针i和j，i是终点，j是起点
- i从0开始遍历，j也从0开始遍历，但是这里要考虑到一点，就是j不可能往回走，因为如果j往回走，那么i在前一步的时候就不会移动到后面的位置。
- 这里使用了两个数组，`q[a[i]]`如果大于1，说明当前位置有重复，那么我们需要让j往后移动，把重复的数字去掉。
- 这里移动的方式是先让`q[a[j]]--`，这是因为防止先`j++`让`q[0]`遍历不到

# 位运算

## 求n二进制的第k位数字

`n >> k & 1`

- 即先把第k位移到最后一位再看个位

## 返回n的最后一位1的位置

` lowbit(n) = n & -n`

- 应用之一是判断n中有多少个1，这个只要每次把最后一位1剪掉就可以，直到没有1 

# 离散化

类似哈希，对于一些数据很大且稀疏的数组，需要用另外的方式把他们保存在一个小数组中。

- `a[]`中可能有重复数据，需要**去重**
- 需要可以快速把某一个数字映射出来，即快速算出`a[i]`离散化后的值（二分）

```c++
vector<int> alls; //存放所有待离散化的值
sort(alls.begin(), alls.end());//将所有值排序
alls.erase(unique(alls.begin(), alls.end()), alls.end());//去除重复元素

//二分求出对应的离散化的值
int find(int x){ // 找到第一个大于等于x的位置
    int l = 0, r = alls.size() - 1;
    while (l < r){
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1; //映射到1, 2, ... , n
}
```

## 区间和

```c++
#include<iostream>
#include<vector>
#include<algorithm>


using namespace std;
typedef pair<int, int> PII;
const int N = 300010;
int n, m;
int a[N]; //存储坐标插入的值（即离散化后存数据的地方）
int s[N]; //存储a[]的前缀和
vector<int> alls; // 存储所有与插入和查询有关的坐标
vector<PII> add, query;

int find(int x){// 返回的是输入的坐标的离散化下标
    int l = 0, r = alls.size() - 1;
    while(l < r){
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1;
}

int main(){
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++){
        int x, c;
        scanf("%d%d", &x, &c);
        add.push_back({x, c});
        alls.push_back(x);
    }
    for (int i = 1; i <= m; i++){
        int l, r;
        scanf("%d%d", &l, &r);
        query.push_back({l, r});
        alls.push_back(l);
        alls.push_back(r);
    }
    // 排序，去重
    sort(alls.begin(), alls.end());
    alls.erase(unique(alls.begin(), alls.end()), alls.end());
    // 执行前n次的插入操作
    for (auto item: add){
        int x = find(item.first);
        a[x] += item.second;
    }
    // 前缀和
    for (int i = 1; i <= alls.size(); i++) s[i] = s[i - 1] + a[i];
    // 处理后m次询问结果
    for (auto item: query){
        int l = find(item.first);
        int r = find(item.second);
        printf("%d\n", s[r] - s[l - 1]);
    }
    
    return 0;
}
```

![8021.png](https://cdn.acwing.com/media/article/image/2020/05/22/38626_05e3618e9b-8021.png)

![8022.png](https://cdn.acwing.com/media/article/image/2020/05/22/38626_08fb69ca9b-8022.png)

# 区间合并

1. 按区间左端点排序

2. 当前维护的区间，设左端点为st，右端点为ed。

    (1) 下一个区间完全被包含在当前区间内

    不需要改变

    (2) 下一个区间和当前区间有交集（不包含）

    ed更新为新的ed

    (3) 无交集

    保存当前区间，然后把st和ed更新为新的区间

```C++
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;

typedef pair<int, int> PII;

int n;
vector<PII> segs;

void merge(vector<PII> &segs){
    vector<PII> res;
    sort(segs.begin(), segs.end());
    
    int st = -2e9, ed = -2e9;
    for (auto seg: segs){
        if (ed < seg.first){
            if (st != -2e9) res.push_back({st, ed});
        st = seg.first, ed = seg.second;
        }

        else ed = max(ed, seg.second);
    }
    
    if (st != -2e9) res.push_back({st, ed});
   segs = res;
}

int main(){
    cin >> n;
    
    for (int i = 0; i < n; i++){
        int l, r;
        cin >> l >> r;
        segs.push_back({l, r});
    }
    merge(segs);
    printf("%d\n", segs.size());
    
    return 0;
}
```

# 数据结构

## 链表

```c++
struct Node{
    int val;
    Node *next;
}; 
new Node();//这个操作非常慢
```

- 用数组模拟链表

### 数组模拟单链表（邻接表）

- 存储图和树
- `e[N]`表示值，`ne[N]`表示`*next`指针，两个数组用下标关联
- 当`ne[i]`为-1时，表示后面已经没有元素（空节点）

```c++
#include <iostream>

using namespace std;

const int N = 100010;

int n;
int h[N], e[N], ne[N], head, idx;

//对链表进行初始化
void init(){
    head = -1;//最开始的时候，链表的头节点要指向-1，
    //为的就是在后面进行不断操作后仍然可以知道链表是在什么时候结束
    /*
    插句题外话，我个人认为head其实就是一个指针，是一个特殊的指针罢了。
    刚开始的时候它负责指向空结点，在链表里有元素的时候，它变成了一个指向第一个元素的指针

    当它在初始化的时候指向-1，来表示链表离没有内容。
    */
    idx = 0;//idx在我看来扮演两个角色，第一个是在一开始的时候，作为链表的下标，让我们好找
    //第二在链表进行各种插入，删除等操作的时候，作为一个临时的辅助性的所要操作的元素的下
    //标来帮助操作。并且是在每一次插入操作的时候，给插入元素一个下标，给他一个窝，感动！
    /*
    再次插句话，虽然我们在进行各种操作的时候，元素所在的下标看上去很乱，但是当我们访问的
    时候，是靠着指针，也就是靠ne[]来访问的，这样下标乱，也就我们要做的事不相关了。
    另外，我们遍历链表的时候也是这样，靠的是ne[]
    */
}
//将x插入到头节点上
void int_to_head(int x){//和链表中间插入的区别就在于它有head头节点
    e[idx] = x;//第一步，先将值放进去
    ne[idx] = head;//head作为一个指针指向空节点，现在ne[idx] = head;做这把交椅的人换了
    //先在只是做到了第一步，将元素x的指针指向了head原本指向的
    head = idx;//head现在表示指向第一个元素了，它不在是空指针了。（不指向空气了）
    idx ++;//指针向下移一位，为下一次插入元素做准备。
}

//将x插入到下标为k的点的后面
void add(int k, int x){
    e[idx] = x;//先将元素插进去
    ne[idx] = ne[k];//让元素x配套的指针，指向它要占位的元素的下一个位置
    ne[k] = idx;//让原来元素的指针指向自己
    idx ++;//将idx向后挪
}

//将下标是k的点后面的点个删掉
void remove(int k){
    ne[k] = ne[ne[k]];//让k的指针指向，k下一个人的下一个人，那中间的那位就被挤掉了。
}
int main(){
    cin >> n;
    init();//初始化
    for (int i = 0; i < n; i ++ ) {
        char s;
        cin >> s;
        if (s == 'H') {
            int x;
            cin >> x;
            int_to_head(x);
        }
        if (s == 'D'){
            int k;
            cin >> k;
            if (k == 0) head = ne[head];//删除头节点
            else remove(k - 1);//注意删除第k个输入后面的数，那函数里放的是下标，k要减去1
        }
        if (s == 'I'){
            int k, x;
            cin >> k >> x;
            add(k - 1, x);//同样的，第k个数，和下标不同，所以要减1
        }
    }

    for (int i = head; i != -1; i = ne[i]) cout << e[i] << ' ' ;
    cout << endl;

    return 0;
}

```





### 数组模拟双链表

- 优化某些问题

```c++
#include<iostream>

using namespace std;

const int N = 1e5 + 10;

int m;
int e[N], l[N], r[N];
int idx;


//! 初始化
void init()
{
    l[1] = 0, r[0] = 1;//* 初始化 第一个点的右边是 1   第二个点的左边是 0
    idx = 2;//! idx 此时已经用掉两个点了
}

//* 在第 K 个点右边插入一个 X 
void add(int k, int x)
{
    e[idx] = x;
    l[idx] = k;
    r[idx] = r[k]; //todo 这边的 k 不加 1 ， 输入的时候 k+1 就好
    l[r[k]] = idx;
    r[k] = idx;
    idx++;
}//! 当然在 K 的左边插入一个数 可以再写一个 ， 也可以直接调用我们这个函数，在 k 的左边插入一个 数 等价于在 l[k] 的右边插入一个数 add(l[k],x)

//*删除第 k个 点
void remove(int k)
{
    r[l[k]] = r[k];
    l[r[k]] = l[k];
}

int main(void)
{
    ios::sync_with_stdio(false);
    cin >> m;

    init();

    while(m--)
    {
        string op;
        cin >> op;
        int k, x;
        if(op=="R")
        {
            cin >> x;
            add(l[1], x); //!   0和 1 只是代表 头和尾  所以   最右边插入 只要在  指向 1的 那个点的右边插入就可以了
        }
        else if(op=="L")//! 同理  最左边插入就是 在指向 0的数的左边插入就可以了   也就是可以直接在 0的 有右边插入
        {
            cin >> x;
            add(0, x);
        }
        else if(op=="D")
        {
            cin >> k;
            remove(k + 1);
        }
        else if(op=="IL")
        {
            cin >> k >> x;
            add(l[k + 1], x);
        }
        else
        {
            cin >> k >> x;
            add(k + 1, x);
        }    
    }
    for(int i = r[0]; i != 1; i = r[i]) cout << e[i] << ' ';

    return 0;
}

```

## 栈

- 后进先出 LIFO

```C++
int stk[N], tt;

// 判断是否为空
if (tt > 0) not empty
else empty
    
// push
stk[++tt] = x;

// pop
tt--;

// query栈顶元素
stk[tt];
```

### 表达式求值

```c++
#include<iostream>
#include<cstring>
#include<algorithm>
#include<stack>
#include<unordered_map>

using namespace std;

stack<int> num;
stack<char> op;

void eval(){
    auto b = num.top(); num.pop();
    auto a = num.top(); num.pop();
    auto c = op.top(); op.pop();
    int x;
    if (c == '+') x = a + b;
    else if (c == '-') x = a - b;
    else if (c == '*') x = a * b;
    else x = a / b;
    num.push(x);
}

int main(){
    unordered_map<char, int> pr{{'+', 1}, {'-', 1}, {'*', 2}, {'/', 2}};
    string str;
    cin >> str;
    for (int i = 0; i < str.size(); i++){
        auto c = str[i];
        if (isdigit(c)){
            int x = 0, j = i;
            while (j < str.size() && isdigit(str[j]))
                x = x * 10 + str[j++] - '0';
            i = j - 1;
            num.push(x);
        }
        else if (c == '(') op.push(c);
        else if (c == ')'){
            while (op.top() != '(') eval();
            op.pop();
        }
        else{
            while (op.size() && pr[op.top()] >= pr[c]) eval();
            op.push(c);
        }
    }
    while (op.size()) eval();
    cout << num.top() << endl;
    return 0;
}
```



## 队列

![2.png](https://cdn.acwing.com/media/article/image/2022/07/15/55289_76ecd06b03-2.png)

```C++
#include <iostream>
using namespace std;
const int N = 100010;
int q[N];

//[hh, tt] 之间为队列（左闭右闭）
int hh = 0;//队头位置
int tt = -1;//队尾位置
//操作次数
int m;
//操作方式
string s;

//入队：队尾先往后移动一格，再放入要插入的数据
void push(int x){
    q[++tt] = x;
}
//出队：队头往后移动一格
void pop(){
    hh++;
}
//[hh, tt]表示队列区间，当tt >= hh时，区间不为空
void empty(){
    if(tt >= hh) cout << "NO" << endl;
    else cout << "YES" << endl;
} 
//hh指向队头，q[hh]代表队头元素
void query (){
    cout << q[hh] << endl;
}

int main(){
    cin >> m;
    while(m--){
        cin >> s;
        //入队
        if(s == "push"){
            int x;
            cin >> x;
            push(x);
        }
        //出队
        if(s == "pop"){
            pop();
        }
        //问空
        if(s == "empty"){
            empty();
        }
        //问队头
        if(s == "query"){
            query();
        }
    }
}
```



## 单调栈

- 只解决一个问题，就是找到它的左边离他最近的数在什么地方（每个数左边第一个比它小的数）

```C++
#include<iostream>
using namespace std;
const int N = 100010;
int stk[N], tt;

int main(){
    int n = 0;
    cin >> n;
    for (int i = 0; i < n; i++){
        int x;
        cin >> x;
        while(tt && stk[tt] >= x) tt--;
        if (tt) cout << stk[tt] << " ";
        else cout << -1 << " ";
        
        stk[++tt] = x;
    }
    return 0;
}
```



## 单调队列（滑动窗口最大值和最小值）

解题思路（以最大值为例）：

由于我们需要求出的是滑动窗口的最大值。

- 如果当前的滑动窗口中有两个下标 i 和 j ，其中i在j的左侧（i<j），并且i对应的元素不大于j对应的元素（nums[i]≤nums[j]），则：

    当滑动窗口向右移动时，只要 i 还在窗口中，那么 j 一定也还在窗口中。这是由于 i 在 j 的左侧所保证的。

    因此，由于 nums[j] 的存在，nums[i] 一定不会是滑动窗口中的最大值了，我们可以将nums[i]永久地移除。

- 因此我们可以使用一个队列存储所有还没有被移除的下标。在队列中，这些下标按照从小到大的顺序被存储，并且它们在数组nums中对应的值是严格单调递减的。

- 当滑动窗口向右移动时，我们需要把一个新的元素放入队列中。

    为了保持队列的性质，我们会不断地将新的元素与队尾的元素相比较，如果新元素大于等于队尾元素，那么队尾的元素就可以被永久地移除，我们将其弹出队列。我们需要不断地进行此项操作，直到队列为空或者新的元素小于队尾的元素。

- 由于队列中下标对应的元素是严格单调递减的，因此此时队首下标对应的元素就是滑动窗口中的最大值。

- 窗口向右移动的时候。因此我们还需要不断从队首弹出元素保证队列中的所有元素都是窗口中的，因此当队头元素在窗口的左边的时候，弹出队头。

```c++
#include<iostream>
using namespace std;

const int N = 1e6 + 10;
int q[N], hh = 0, tt = -1;
int a[N];

int main(){
    int n, k;
    scanf("%d%d", &n, &k);
    for (int i = 0; i < n; i++) scanf("%d", &a[i]);
    for (int i = 0; i < n; i++){
        // 判断队头是否已经滑出了队列
        if (hh <= tt && i - k + 1 > q[hh]) hh++;
        while (hh <= tt && a[q[tt]] >= a[i]) tt--;
        q[++tt] = i;
        if (i >= k - 1) printf("%d ", a[q[hh]]);
    }
    puts("");
    hh = 0, tt = -1;
    for (int i = 0; i < n; i++){
        // 判断队头是否已经滑出了队列
        if (hh <= tt && i - k + 1 > q[hh]) hh++;
        while (hh <= tt && a[q[tt]] <= a[i]) tt--;
        q[++tt] = i;
        if (i >= k - 1) printf("%d ", a[q[hh]]);
    }
    puts("");
}
```

# KMP

- 最大公共前后缀

```c++
#include<iostream>
using namespace std;

const int N = 100010, M = 1000010;

int n, m;
char p[N], s[M];
int ne[N];

int main(){
    cin >> n >> p + 1 >> m >> s + 1;
    
    // 求next的过程
    for(int i = 2, j = 0; i <= n; i++){
        while(j && p[i] != p[j + 1]) j = ne[j];
        if (p[i] == p[j + 1]) j++;
        ne[i] = j;
    }
    
    // kmp匹配过程
    for (int i = 1, j = 0; i <= m; i++){
        while(j && s[i] != p[j + 1]) j = ne[j];
        if (s[i] == p[j + 1]) j++;
        if (j == n){
            printf("%d ", i - n);
            j = ne[j];
        }
    }
    return 0;
}
```

# Trie树

- 用于快速存储和查找字符串集合的结构

```c++
#include<iostream>

using namespace std;

const int N = 100010;

int son[N][26], cnt[N], idx; // 因为只有26个字母，也就只可能有26个子节点。cnt保存的是每个单词出现的次数，也是存储了当前位置是否是单词。使用idx和单链表类似，这个地方可以和cnt对应
char str[N];

void insert(char str[]){
    int p = 0;
    for (int i = 0; str[i]; i++){
        int u = str[i] - 'a';
        if (!son[p][u]) son[p][u] = ++idx;
        p = son[p][u];
    }
    cnt[p]++;
}

int query(char str[]){
    int p = 0;
    for (int i = 0; str[i]; i++){
        int u = str[i] - 'a';
        if (!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}

int main(){
    int n = 0;
    cin >> n;
    while (n--){
        char op[2];
        scanf("%s%s", op, str);
        if (op[0] == 'I') insert(str);
        else printf("%d", query(str));
    }
    return 0;
}
```

## 最大异或对

```c++
#include<iostream>
using namespace std;

const int N = 100010;

int son[32 * N][2], idx;
int a[N];

void insert(int x)
{
    int p = 0;  //根节点
    for(int i = 30;i >= 0;i--)
    {
        int u = x >> i & 1;   /////取X的第i位的二进制数是什么  x>>k&1(前面的模板)
        if(!son[p][u]) son[p][u] = ++idx; ///如果插入中发现没有该子节点,开出这条路
        p = son[p][u]; //指针指向下一层
    }
}

int search(int x)
{
    int p = 0;int res = 0;
    for(int i = 30; i >= 0; i--)
    {                               ///从最大位开始找
        int u = x >> i & 1;
        if(son[p][!u]) ////如果当前层有对应的不相同的数
        {   ///p指针就指到不同数的地址

          p = son[p][!u];
          res = res*2+1;
             ///*2相当左移一位  然后如果找到对应位上不同的数res+1 例如    001
        }                                                       ///       010 
        else                                            ////          --->011                                                                           //刚开始找0的时候是一样的所以+0    到了0和1的时候原来0右移一位,判断当前位是同还是异,同+0,异+1
        {
            p = son[p][u];
            res = res*2+0;
        }
    }
    return res;
}

int main(){
    int n = 0;
    cin >> n;
    for (int i = 0; i < n; i++){
        cin >> a[i];
        insert(a[i]);
    }
    int res = 0;
    for (int i = 0; i < n; i++){
        res = max(res, search(a[i]));
    }
    printf("%d\n", res);
    return 0;
}
```

# 并查集

- 快速地将两个集合合并
- 询问两个元素是否在一个集合当中（近乎O(1)）

基本原理：

- 用树的形式维护所有集合
- 树根的编号就是整个集合的编号，p[x]表示x的父节点

几个问题

- 问题1：如何判断树根?`if (p[x] == x)`
- 问题2：如何求x的集合编号？`while(p[x] != x) x = p[x];`
- 问题3：如何合并两个集合？设px是x节点的编号，py是y节点的编号，只需要让`p[x] = y`

问题二耗时较多，那么可以在遍历时，直接让路径上的点都指向根节点（路径压缩）

## 合并集合（最简单的并查集）

```c++
#include<iostream>
using namespace std;

const int N = 100010;

int n, m;
int p[N];

int find(int x){ // 返回x所在集合的编号（祖宗节点）+路径压缩
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int main(){
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) p[i] = i;
    
    while (m--){
        char op[2];
        int a, b;
        scanf("%s%d%d", op, &a, &b);
        
        if (op[0] == 'M') p[find(a)] = find(b);
        else if (op[0] == 'Q'){
            if (find(a) == find(b)) puts("Yes");
            else puts("No");
        }
    }
    return 0;
}
```

如果还要保留每个集合中的元素数目：

```c++
#include<iostream>
using namespace std;

const int N = 100010;
int n, m;
int p[N], sz[N]; // 只保证根节点的size是有意义的就可以了

int find(int x){
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int main(){
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++){
        p[i] = i;
        sz[i] = 1;
    }
    while (m--){
        char op[5];
        int a, b;
        scanf("%s", op);
        
        if (op[0] == 'C'){
            scanf("%d%d", &a, &b);
            if (find(a) == find(b)) continue;
            sz[find(b)] += sz[find(a)];
            p[find(a)] = find(b);
        }
        else if (op[1] == '1'){
            scanf("%d%d", &a, &b);
            if (find(a) == find(b)) puts("Yes");
            else puts("No");
        }
        else{
            scanf("%d", &a);
            printf("%d\n", sz[find(a)]);
        }
    }
    return 0;
}
```

# 堆

如何手写一个堆？

1. 插入一个数 `heap[++size] = x; up(size);`
2. 求集合当中的最小值 `heap[1]`
3. 删除最小值 `heap[1] = heap[size]; size--; down(1);`
4. 删除任意一个元素 `heap[k] = heap[size]; size--; down(k); up(k);`
5. 修改任意一个元素 `heap[k] = x; down(k); up(k);`

堆是一个完全二叉树

对于小根堆，每个父节点都小于左右儿子。

## 堆排序

```c++
#include<iostream>
#include<algorithm>

using namespace std;

const int N = 100010;

int n, m;
int h[N], sz;


void down(int u){
    int t = u;
    if (u * 2 <= sz && h[u * 2] < h[t]) t = u * 2;
    if (u * 2 + 1 <= sz && h[u * 2 + 1] < h[t]) t = u * 2 + 1;
    if (u != t){
        swap(h[u], h[t]);
        down(t);
    }
}

void up(int u){
    while (u / 2 && h[u / 2] > h[u]){
        swap(h[u / 2], h[u]);
        u /= 2;
    }
}

int main(){
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) scanf("%d", &h[i]);
    sz = n;
    for (int i = n / 2; i > 0; i--) down(i);
    
    while(m--){
        printf("%d ", h[1]);
        h[1] = h[sz];
        sz--;
        down(1);
    }
    return 0;
}
```

## 模拟堆（带映射，即含第几个插入信息）

```c++
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;

const int N = 100010;

int n, m;
int h[N], ph[N], hp[N], sz;

void heap_swap(int a, int b){
    swap(ph[hp[a]], ph[hp[b]]);
    swap(hp[a], hp[b]);
    swap(h[a], h[b]);
}

void down(int u){
    int t = u;
    if (u * 2 <= sz && h[u * 2] < h[t]) t = u * 2;
    if (u * 2 + 1 <= sz && h[u * 2 + 1] < h[t]) t = u * 2 + 1;
    if (u != t){
        heap_swap(u, t);
        down(t);
    }
}

void up(int u){
    while (u / 2 && h[u / 2] > h[u]){
        heap_swap(u / 2, u);
        u /= 2;
    }
}

int main(){
    scanf("%d", &n);
    while (n--) {
        char op[10];
        int k, x;
        
        scanf("%s", op);
        if (!strcmp(op, "I")){
            scanf("%d", &x);
            sz++;
            m++;
            ph[m] = sz;
            hp[sz] = m;
            h[sz] = x;
            up(sz);
        }
        else if (!strcmp(op, "PM")) printf("%d\n", h[1]);
        else if (!strcmp(op, "DM")) {
            heap_swap(1, sz);
            sz--;
            down(1);
        }
        else if (!strcmp(op, "D")){
            scanf("%d", &k);
            k = ph[k];
            heap_swap(k, sz);
            sz--;
            down(k), up(k);
        }
        else{
            scanf("%d%d", &k, &x);
            k = ph[k];
            h[k] = x;
            down(k), up(k);
        }
    }
    return 0;
}
```

# 哈希表

1. 存储结构

    - 开放寻址法

        ```c++
        #include<cstring>
        #include<iostream>
        
        using namespace std;
        
        const int N = 200003, null = 0x3f3f3f3f;
        
        int h[N];
        
        int find(int x){
            int k = (x % N + N) % N;
            while(h[k] != null && h[k] != x){
                k++;
                if (k == N) k = 0;
            }
            return k;
        }
        
        int main(){
            int n;
            scanf("%d", &n);
            
            memset(h, 0x3f3f3f3f, sizeof h);
            
            while(n--){
                char op[2];
                int x;
                scanf("%s%d", op, &x);
                int k = find(x);
                if (op[0] == 'I') h[k] = x;
                else {
                    if (h[k] != null) puts("Yes");
                    else puts("No");
                }
            }
            return 0;
        }
        
        ```

        

    - 拉链法

        对于每一个位置，使用一个链表存储冲突的数

        ```c++
        #include<iostream>
        #include<cstring>
        using namespace std;
        
        const int N = 100003; // 质数比较不容易冲突
        
        int h[N], e[N], ne[N], idx;
        
        void insert(int x){
            int k = (x % N + N) % N; // C++里面的模，当为负数时为负，当为整数时为正，这里需要将它变为正数
            e[idx] = x;
            ne[idx] = h[k];
            h[k] = idx++;
        }
        
        bool find(int x){
            int k = (x % N + N) % N;
            for (int i = h[k]; i != -1; i = ne[i]){
                if (e[i] == x) return true;
            }
            return false;
        }
        
        int main(){
            int n;
            scanf("%d", &n);
            
            memset(h, -1, sizeof h);
            
            while(n--){
                char op[2];
                int x;
                scanf("%s%d", op, &x);
                if (op[0] == 'I') insert(x);
                else{
                    if (find(x)) puts("Yes");
                    else puts("No");
                }
            }
            
            return 0;
        }
        ```

        

2. 字符串哈希方式(字符串前缀哈希法)

​	字符串哈希的计算方式：

（1）把字符串看作是p进制的数

（2）不能把任何一个字母映射成0，这是因为如果把A映射为0，则AA也是0，这样就没有意义了

（3）这里需要假定不存在冲突（p = 131或13331，Q = $2^{64}$，这样基本不会出现冲突的问题）

- 哈希表的作用：使用哈希函数将一个大范围的数映射到一个小范围（数字比较稀疏）

- 哈希函数：直接取模（模最多能存的范围）

- 冲突，按冲突处理方式分为开放寻址法和拉链法

对形如 $X_1X_2X_3\cdots X_{n-1}X_n$ 的字符串,采用字符的ascii 码乘上 P 的次方来计算哈希值。

映射公式 $(X_1 \times P^{n-1} + X_2 \times P^{n-2} + \cdots + X_{n-1} \times P^1 + X_n \times P^0) \bmod Q$

​	问题是比较不同区间的子串是否相同，就转化为对应的哈希值是否相同。
​	求一个字符串的哈希值就相当于求前缀和，求一个字符串的子串哈希值就相当于求部分和。
前缀和公式    $h[i+1] = h[i] \times P + s[i]$ $i \in [0,n-1]$ h为前缀和数组，s为字符串数组
区间和公式    $h[l,r] = h[r] - h[l-1] \times P^{r-l+1}$
​	区间和公式的理解: ABCDE 与 ABC 的前三个字符值是一样，只差两位，乘上 $P^2$ 把 ABC 变为 ABC00，再用 ABCDE - ABC00 得到 DE 的哈希值。

```c++
#include<cstdio>
#include<string>
using namespace std;
typedef unsigned long long ULL;
const int N = 1e5+5,P = 131;//131 13331
ULL h[N],p[N];

// h[i]前i个字符的hash值
// 字符串变成一个p进制数字，体现了字符+顺序，需要确保不同的字符串对应不同的数字
// P = 131 或  13331 Q=2^64，在99%的情况下不会出现冲突
// 使用场景： 两个字符串的子串是否相同
ULL query(int l,int r){
    return h[r] - h[l-1]*p[r-l+1];
}
int main(){
    int n,m;
    cin>>n>>m;
    string x;
    cin>>x;

    //字符串从1开始编号，h[1]为前一个字符的哈希值
    p[0] = 1;
    h[0] = 0;
    for(int i=0;i<n;i++){
        p[i+1] = p[i]*P;            
        h[i+1] = h[i]*P +x[i];      //前缀和求整个字符串的哈希值
    }

    while(m--){
        int l1,r1,l2,r2;
        cin>>l1>>r1>>l2>>r2;
        if(query(l1,r1) == query(l2,r2)) printf("Yes\n");
        else printf("No\n");

    }
    return 0;
}
```

# STL

```c++
/*
vector，变长数组，倍增的思想
    size() 当前元素个数
    empty() 是否为空
    clear() 清空 
    front()/back() 第一个数和最后一个数
    push_back()/pop_back() 可以当做栈来使用
    begin()/end() 迭代器，第一个数和最后一个数后面一个数
    支持比较运算，按字典序比较

pair<int, int> 存储一个二元组
    p.first, p.second 第一个元素和第二个元素
    支持比较运算，同样按字典序比较，以first为第一个关键字，以second为第二个关键字
    也可以pair<int, pair<int, string>>，这样就可以存储三个内容

string，字符串，substr(), c_str()
	  size() 当前元素个数
	  empty() 是否为空
	  支持加法，即连接两个字符串
	  s.substr(起始下标, 返回几个字母)，超过长度只会到末尾
	  s.c_str() 返回s存储的字符串的起始地址

queue，队列
	push() 向队尾插入一个元素
	front() 返回队头元素
	back() 返回队尾元素
	pop() 弹出队头元素

priority_queue，优先队列，使用堆实现的，默认是大根堆
	push() 插入一个元素
	pop() 弹出堆顶元素
	top() 返回堆顶元素
	想要得到小根堆有两种方式，一种是直接插入-x，另一种是直接定义为小根堆（priority_queue<int, vector<int>, greater<int>> heap;）
	
stack，栈
	push() 向栈顶插入一个元素
	pop() 弹出栈顶元素
	top() 返回栈顶元素

deque，双端队列，两端都可插入弹出，很慢
	size()
	empty()
	clear()
	front()
	back()
	push_back()/pop_back()
	push_front()/pop_front()
	支持[]
	begin()/end()
	
set, map, multiset, multimap，基于平衡二叉树（红黑树），动态维护有序序列
	size()
	empty()
	clear()
	begin()/end() ++, -- 返回前驱和后继，时间复杂度是O(logn)
	
	set/multiset
		insert() 插入一个数
		find() 查找一个数
		count() 返回某一个数的个数
		erase()
			(1) 输入是一个数x，删除所有x O(k + log n)
			(2) 输入是一个迭代器，删除这个迭代器
		lower_bound()/upper_bound()
			前者返回大于等于x的最小的数的迭代器，不存在返回end()
			后者返回大于x的最小的数的迭代器，不存在返回end()
			
	map/multimap map<int, string> 类似python的字典
		insert() 插入的数是一个pair
		erase() 输入的参数是pair或迭代器
		find()
		[] 时间复杂度是O(logn)
		lower_bound()/upper_bound()

unordered_set, unordered_map, unordered_multiset, unordered_multimap，哈希表
	这些与上面的类似，但复杂度是O(1)，不支持lower_bound()/upper_bound()和++, --(凡是和排序有关的操作都不支持)
	
bitset，压位
	例如我们想开一个1024的bool数组（C++的bool是一字节），我们可以开一个bitset，这样每一位存一个bool，可以只花费八分之一的内存。
	bitset<10000> s;
	~, &, |, ^
	>>, <<
	==, !=
	[]
	
	count() 返回有多少个1
	
	any() 判断是否有一个1
	none() 判断是否全为零
	
	set() 把所有位置成1
	set(k, v) 把第k位置为v
	reset() 把所有位置成0
	flip() 等价于~
	flip(k) 把第k位取反
*/
#include<iostream>
#include<cstring>
#include<algorithm>
#include<vector>

using namespace std;

int main(){
    vector<int> a(10, 3); //长度为10，每个数字都是3
    a.size();  //这两个函数不止vector，每个STL都有
    a.empty(); //
    
}
```

# 搜索与图论

## DFS

栈（空间复杂度$O(h)$）

1. 回溯

    

2. 剪枝

    

```c++
#include<iostream>
using namespace std;

const int N = 10;
int n;
int path[N];
bool st[N];

void dfs(int u){
    if (u == n){
        for (int i = 0; i < n; i++) printf("%d ", path[i]);
        puts("");
    }
    
    for (int i = 1; i <= n; i++){
        if (!st[i]){
            path[u] = i;
            st[i] = true;
            dfs(u + 1);
            st[i] = false;
        }
    }
}

int main(){
    cin >> n;
    dfs(0);
    return 0;
}
```

### n皇后问题

```c++
#include <iostream>
using namespace std;

const int N = 11;

char q[N][N];//存储棋盘
bool dg[N * 2], udg[N * 2], cor[N];//点对应的两个斜线以及列上是否有皇后

int n;

void dfs(int r)
{
    if(r == n)//放满了棋盘，输出棋盘
    {
        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j < n; j++)
                cout << q[i][j];
            cout << endl;
        }
        cout << endl;
        return;
    }

    for(int i = 0; i < n; i++)//第 r 行，第 i 列 是否放皇后
    {
        if(!cor[i] && !dg[i + r] && !udg[n - i + r])//不冲突，放皇后
        {
            q[r][i] = 'Q';
            cor[i] = dg[i + r] = udg[n - i + r] = 1;//对应的 列， 斜线 状态改变
            dfs(r + 1);//处理下一行
            cor[i] = dg[i + r] = udg[n - i + r] = 0;//恢复现场
            q[r][i] = '.';
        }
    }
}

int main()
{
    cin >> n;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n; j ++ )
            q[i][j] = '.';
    dfs(0);
    return 0;
}
```



## BFS

队列（空间复杂度$O(2^h)$） 最短路

```c++
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
const int N = 110;
typedef pair<int, int> PII;
int n, m;
int g[N][N], d[N][N];
PII q[N * N];

int bfs(){
    int hh = 0, tt = -1;
    memset(d, -1, sizeof d);
    q[++tt] = {1, 1};
    d[1][1] = 0;
    int dx[4] = {1, -1, 0, 0};
    int dy[4] = {0, 0, 1, -1};
    while (hh <= tt){
        auto t = q[hh++];
        for(int i = 0; i < 4; i++){
            int x = t.first + dx[i], y = t.second + dy[i];
            if (x > 0 && x <= n && y > 0 && y <= m && g[x][y] == 0 && d[x][y] == -1){
                d[x][y] = d[t.first][t.second] + 1;
                q[++tt] = {x, y};
            }
        }
    }
    return d[n][m];
}

int main(){
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
            scanf("%d", &g[i][j]);
    int res = bfs();
    cout << res << endl;
    return 0;
}
```

### 八数码

```c++
#include <iostream>
#include <cstring>
#include <algorithm>
#include <unordered_map>
#include <queue>

using namespace std;
// 保存各个序列
queue<string> q;
string s;
// 保存序列与对应的交换次数
unordered_map<string, int> h;

int main()
{
    // 输入原始序列
    for(int i = 1; i <= 9; i++)
    {
        char c;
        cin >> c;
        s += c;
    }
    // 保存初始状态
    h[s] = 0;
    q.push(s);
    // 定义上下左右四个交换方向
    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

    // 依次进行交换
    while(!q.empty())
    {
        // 获得当前序列
        string t = q.front();
        q.pop();
        // 如果是最后结果，输出答案
        if(t == "12345678x")
        {
            cout << h[t] << endl;
            return 0;
        }
        // 找到 x 的位置
        int pos = t.find('x');
        // 计算 x 的坐标
        int a = pos /3 , b = pos % 3 ;
        // 获取当前序列对应的交换次数
        int dist = h[t];

        // 尝试和四个方向的元素进行交换
        for(int i = 0; i < 4; i++)
        {
            int x = a + dx[i], y = b + dy[i];
            // 判断是否越界
            if(x >= 0 && x <= 2 && y >= 0 && y <= 2)
            {
                // 交换
                swap(t[pos], t[3 * x + y]);
                // 如果是个新序列，就保存新序列和对应的交换次数
                if(h.find(t) == h.end())
                {
                    h[t] = dist + 1;
                    q.push(t);
                }
                // 恢复现场，进行下一个方向的交换
                swap(t[pos], t[3 * x + y]);
            }
        }
    }
    // 没有得到结果序列，输出-1
    cout << -1;
    return 0;
}
```





## 树与图的深度优先遍历

图分为有向图和无向图，但是无向图可以看做一种特殊的有向图，即把每条边都建立正向和反向的边。

有向图有两种存储方式，一种是邻接矩阵，这种方式$O(n^2)$，适合存储稠密图。

另一种是邻接表，就是使用单链表来存储。（见哈希表拉链法）

```c++
#include<iostream>
#include<cstring>
using namespace std;

const int N = 100010;
int e[N * 2], ne[N * 2], h[N], idx;
int n;
bool st[N];
int ans = N;

void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

int dfs(int u){
    st[u] = true;
    int sum = 1, res = 0;
    for (int i = h[u]; i != -1; i = ne[i]){
        int j = e[i];
        if (!st[j]){
            int s = dfs(j);
            res = max(res, s);
            sum += s;
        }
    }
    res = max(res, n - sum);
    
    ans = min(ans, res);
    return sum;
}

int main(){
    cin >> n;
    memset(h, -1, sizeof h);
    for (int i = 0; i < n - 1; i++){
        int a, b;
        cin >> a >> b;
        add(a, b);
        add(b, a);
    }
    dfs(1);
    cout <<ans << endl;
    return 0;
}
```





## 树与图的广度优先遍历

```c++
#include<iostream>
#include<cstring>

using namespace std;

const int N = 100010;

int n, m;
int h[N], e[N], ne[N], idx;
int d[N], q[N];

void add(int a, int b){
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

int bfs(){
    int hh = 0, tt = 0;
    q[0] = 1;
    
    memset(d, -1, sizeof d);
    d[1] = 0;
    while(hh <= tt){
        int t = q[hh++];
        
        for (int i = h[t]; i != -1; i = ne[i]){
            int j = e[i];
            if (d[j] == -1){
                q[++tt] = j;
                d[j] = d[t] + 1;
            }
        }
    }
    return d[n];
}

int main(){
    cin >> n >> m;
    
    memset(h, -1, sizeof h);
    for (int i = 0; i < m; i++){
        int a, b;
        cin >> a >> b;
        add(a, b);
    }
    
    cout << bfs() << endl;
    return 0;
}
```





## 拓扑排序

拓扑序列：在图中起点在终点的前面

入度 出度

入度为0的点入队

宽搜，取队头，枚举t所有出边j

删掉t，让j的入度--，如果入度为0，那么我们把它入队

（一个有向无环图一定存在一个入度为0的点）

```c++
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;

const int N = 100010;

int n, m;
int h[N], e[N], ne[N], idx;
int q[N], d[N];

void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

bool topsort(){
    int hh = 0, tt = -1;
    for (int i = 1; i <= n; i++){
        if (!d[i])
            q[++tt] = i;
    }
    while(hh <= tt){
        int t = q[hh++];
        for (int i = h[t]; i != -1; i = ne[i]){
            int j = e[i];
            d[j]--;
            if (d[j] == 0) q[++tt] = j;
        }
    }
    return tt == n - 1;
}

int main(){
    cin >> n >> m;
    
    memset(h, -1, sizeof h);
    
    for (int i = 0; i < m; i++){
        int a, b;
        cin >> a >> b;
        add(a, b);
        d[b]++;
    }
    
    if (topsort()){
        for(int i = 0; i < n; i++) printf("%d ", q[i]);
    }
    else puts("-1");
    
    return 0;
}

```



## Dijkstra

最短路

​	单源最短路（一个点到其他所有点的最短路）

​		所有边权都是正数

​			朴素Dijkstra算法 $O(n^2)$ 适合稠密图 $m$和$n^2$是一个级别看作稠密图

​			堆优化的Dijkstra算法 $O(mlogn)$ 适合稀疏图 $m$和$n$是一个级别看作稀疏图

​		存在负权边

​			Bellman-Ford $O(nm)$

​			SPFA 一般$O(m)$，最坏$O(nm)$

​	多源汇最短路（起点和终点都不确定）

​		Floyd算法 $O(n^3)$​

- 朴素Dijkstra
    1. `dist[1]=0; dist[i]=INF`，建立一个集合`s`，表示当前已经确定最短距离的点
    2. `for i: 0 to n`取不在`s`中的距离最近的点`t` ，`s=s+t`
    3. 用t更新其他点的距离

```c++
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;
const int N = 510;

int n, m;
int g[N][N];
int dist[N];
bool st[N];

int dijkstra(){
    memset(dist, 0x3f3f3f3f, sizeof dist);
    
    dist[1] = 0;
    
    for(int i = 0; i < n; i++){// 最多要n步到达点n
        int t = -1;
        for(int j = 1; j <= n; j++)// 遍历每一个点
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
        st[t] = true;
        
        for (int j = 1; j <= n; j++)
            dist[j] = min(dist[j], dist[t] + g[t][j]);
    }
    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}

int main(){
    scanf("%d%d", &n, &m);
    
    memset(g, 0x3f3f3f3f, sizeof g);
    
    while(m--){
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        g[a][b] = min(g[a][b], c);
    }
    
    int t = dijkstra();
    
    printf("%d\n", t);
    
    return 0;
}
```

- 堆优化的Dijkstra

```c++
#include<iostream>
#include<cstring>
#include<algorithm>
#include<queue>

using namespace std;

typedef pair<int, int> PII;
const int N = 150010;

int n, m;
int h[N], e[N], ne[N], w[N], idx;
int dist[N];
bool st[N];

void add(int a, int b, int c){
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
}

int dijkstra(){
    memset(dist, 0x3f3f3f3f, sizeof dist);
    dist[1] = 0;
    
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, 1});
    while(heap.size()){
        auto t = heap.top();
        heap.pop();
        
        int ver = t.second, distance = t.first;
        if (st[ver]) continue; //由于priority_queue是冗余设计的，它里面的元素并没有真正地弹出，可能现在弹出的是以前已经弹出过的，因此这里需要忽略它
        st[ver] = true;
        for (int i = h[ver]; i != -1; i = ne[i]){
            int j = e[i];
            if (dist[j] > distance + w[i]){
                dist[j] = distance + w[i];
                heap.push({dist[j], j});
            }
        }
    }
    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}


int main(){
    scanf("%d%d", &n, &m);
    
    memset(h, -1, sizeof h);
    
    while(m--){
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
    }
    
    int t = dijkstra();
    
    printf("%d\n", t);
    return 0;
}
```



## bellman-ford

`for n次	for 所有边a, b, w	dist[b] = min(dist[b], dist[a] + w)`

松弛 不能有负权回路，否则不能得到正确的距离，但是其实可以用这个判断这个是否有负权环

有边数限制的最短路

```c++
#include<cstring>
#include<iostream>
#include<algorithm>

using namespace std;

const int N = 510, M = 10010;

int n, m, k;
int dist[N], backup[N];

struct Edge{
    int a, b, w;
}edges[M];

int bellman_ford(){
    memset(dist, 0x3f3f3f3f, sizeof dist);
    dist[1] = 0;
    for (int i = 0; i < k; i++){
        memcpy(backup, dist, sizeof dist);
        for (int j = 0; j < m; j++){
            int a = edges[j].a, b = edges[j].b, w = edges[j].w;
            dist[b] = min(dist[b], backup[a] + w);
        }
    }
    if (dist[n] > 0x3f3f3f3f / 2) return 0x3f3f3f3f;//这是因为存在负权边时，它可能会更新本来是inf的边
    return dist[n];
}

int main(){
    scanf("%d%d%d", &n, &m, &k);
    
    for (int i = 0; i < m; i++){
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        edges[i] = {a, b, c};
    }
    
    int t = bellman_ford();
    
    if (t == 0x3f3f3f3f) printf("impossible");
    else printf("%d", t);
    
    return 0;
}
```



## spfa

除了不能处理负环，都可以使用

spfa最短路径

```c++
#include<iostream>
#include<cstring>
#include<algorithm>
#include<queue>

using namespace std;

const int N = 100010;

int n, m;
int h[N], e[N], ne[N], w[N], idx;
int dist[N];
bool st[N];

void add(int a, int b, int c){
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
}

int spfa(){
    memset(dist, 0x3f3f3f3f, sizeof dist);
    dist[1] = 0;
    
    queue<int> q;
    q.push(1);
    st[1] = true;
    while(q.size()){
        int t = q.front();
        q.pop();
        
        st[t] = false;
        
        for (int i = h[t]; i != -1; i = ne[i]){
            int j = e[i];
            if(dist[j] > dist[t] + w[i]){
                dist[j] = dist[t] + w[i];
                if (!st[j]){
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }
    if (dist[n] == 0x3f3f3f3f) return 0x3f3f3f3f;
    return dist[n];
}

int main(){
    scanf("%d%d", &n, &m);
    
    memset(h, -1, sizeof h);
    
    while(m--){
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
    }
    
    int t = spfa();
    
    if (t == 0x3f3f3f3f) printf("impossible");
    else printf("%d\n", t);
}
```



spfa判断负权环

```c++
#include<iostream>
#include<cstring>
#include<algorithm>
#include<queue>

using namespace std;

const int N = 100010;

int n, m;
int h[N], e[N], ne[N], w[N], idx;
int dist[N], cnt[N];
bool st[N];

void add(int a, int b, int c){
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
}

int spfa(){
    queue<int> q;
    
    for(int i = 1; i <= n; i++){
        st[i] = true;
        q.push(i);
    }
    
    while(q.size()){
        int t = q.front();
        q.pop();
        
        st[t] = false;
        
        for (int i = h[t]; i != -1; i = ne[i]){
            int j = e[i];
            if(dist[j] > dist[t] + w[i]){
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + 1;
                
                if (cnt[j] >= n) return true;
                if (!st[j]){
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }
    return false;
}

int main(){
    scanf("%d%d", &n, &m);
    
    memset(h, -1, sizeof h);
    
    while(m--){
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
    }
    
    if (spfa()) puts("Yes");
    else puts("No");
    return 0;
}
```





## Floyd

```c++
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;

const int N = 210, INF = 1e9;

int n, m, Q;
int d[N][N];

void floyd(){
    for (int k = 1; k <= n;k++)
        for(int i = 1; i <= n; i++)
            for(int j = 1; j <= n; j++)
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}

int main(){
    scanf("%d%d%d", &n, &m, &Q);
    
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            if (i == j) d[i][j] = 0;
            else d[i][j] = INF;
    while(m--){
        int a, b, w;
        scanf("%d%d%d", &a, &b, &w);
        d[a][b] = min(d[a][b], w);
    }
    floyd();
    
    while(Q--){
        int a, b;
        scanf("%d%d", &a, &b);
        if (d[a][b] > INF / 2) printf("impossible\n");
        else printf("%d\n", d[a][b]);
    }
    
    return 0;
}
```



## Prim

最小生成树（都对应无向图）

Prim 稠密图上使用朴素版Prim($O(n^2)$)，稀疏图上使用堆优化版的Prim($O(mlogn)$)

```
dist[i] <- +INF
for(i=0;i<n;i++)
	t<-找到集合外距离最近的点
	用t更新其它点到集合的距离
	st[t]=true
```

```c++
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;

const int N = 510, INF = 0x3f3f3f3f;

int n, m;
int g[N][N];
int dist[N];
bool st[N];

int prim(){
    memset(dist, 0x3f3f3f3f, sizeof dist);
    
    int res = 0;
    for(int i = 0; i < n; i++){
        int t = -1;
        for (int j = 1; j <= n; j++)
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
        if (i && dist[t] == INF) return INF;
        
        for (int j = 1; j <= n; j++) dist[j] = min(dist[j], g[t][j]);
        
        if (i) res += dist[t];
        st[t] = true;
    }
    return res;
}

int main(){
    scanf("%d%d", &n, &m);
    
    memset(g, 0x3f3f3f3f, sizeof g);
    
    while(m--){
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        if (a == b) continue;
        g[a][b] = g[b][a] = min(g[a][b], c);
    }
    
    int t = prim();
    
    if (t == INF) puts("impossible");
    else printf("%d\n", t);
    return 0;
}
```





## Kruskal

$O(mlogm)$

1. 将所有边按从小到大排序

2. 枚举每条边a, b，权重为c

    if a, b不联通

    ​	将这条边加入集合中（并查集）

```c++
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;

const int N = 200010;

int n, m;
int p[N];

struct Edge{
    int a, b, w;
    bool operator< (const Edge &W)const{
        return w < W.w;
    }
}edges[N];

int find(int x){
    if(p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int main(){
    scanf("%d%d", &n, &m);
    for (int i = 0; i < m; i++){
        int a, b, w;
        scanf("%d%d%d", &a, &b, &w);
        edges[i] = {a, b, w};
    }
    sort(edges, edges + m);
    
    for (int i = 1; i <= n; i++) p[i] = i;
    
    int res = 0, cnt = 0;
    for (int i = 0; i < m; i++){
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;
        
        a = find(a), b = find(b);
        if(a != b){
            p[a] = b;
            res += w;
            cnt++;
        }
    }
    if (cnt < n - 1) puts("impossible");
    else printf("%d\n", res);
}
```





## 染色法判定二分图

二分图 一个图是二分图，当且仅当图中不含奇数环

$O(n+m)$

```c++
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;

const int N = 100010, M = 200010;

int n, m;
int h[M], e[M], ne[M], idx;
int color[N];

void add(int a, int b){
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

bool dfs(int u, int c){
    color[u] = c;
    
    for (int i = h[u]; i != -1; i = ne[i]){
        int j = e[i];
        if (!color[j]){
            if (!dfs(j, 3 - c)) return false;
        }
        else if (color[j] == c) return false;
    }
    return true;
}

int main(){
    scanf("%d%d", &n, &m);
    
    memset(h, -1, sizeof h);
    
    while(m--){
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b), add(b, a);
    }
    bool flag = true;
    for(int i = 1; i <= n; i++){
        if (!color[i]){
            if(!dfs(i, 1)){
                flag = false;
                break;
            }
        }
    }
    if (flag) puts("Yes");
    else puts("No");
    return 0;
}
```



## 匈牙利算法

$O(nm)$，实际运行效果远小于这个复杂度

```c++
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;
const int N = 510, M = 100010;

int n1, n2, m;
int h[N], e[M], ne[M], idx;
int match[N];
bool st[N];

void add(int a, int b){
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

bool find(int x){
    for (int i = h[x]; i != -1; i = ne[i]){
        int j = e[i];
        if(!st[j]){
            st[j] = true;
            if (match[j] == 0 || find(match[j])){
                match[j] = x;
                return true;
            }
        }
    }
    return false;
}

int main(){
    scanf("%d%d%d", &n1, &n2, &m);
    memset(h, -1, sizeof h);
    
    while(m--){
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b);
    }    
    int res = 0;
    for (int i = 1; i <= n1; i++){
        memset(st, false, sizeof(st));
        if(find(i)) res++;
    }

    printf("%d", res);
    return 0;
}
```

# 数论

## 质数

- 定义：（大于1的自然数）除了1与它本身外没有其他约数的数

### 质数的判定——试除法

$O(\sqrt{n})$

```c++
bool is_prime(int n){
    if (n < 2) return false;
    for (int i = 2; i <= n / i; i++){// 这是因为只要计算到根号n就可以了，但是开根号运算较慢而且使用i * i有溢出风险因此使用这种写法
        if(n % i == 0) return false;
    }
    return true;
}
```

### 分解质因数——试除法

从小到大枚举所有的数，同样只需要枚举到$\sqrt{n}$，

n中最多只包含一个大于$\sqrt{n}$的质因子

我们先把所有小于等$\sqrt{n}$的数除掉，最后剩下的就是唯一的大于$\sqrt{n}$​的质因子。

$O(logn)~O(\sqrt{n})$

```c++
void devide(int x){
    for (int i = 2; i <= n / i; i++){
        if (n % i == 0){
            int s =0;
            while(n % i == 0){
                n /= i;
                s++;
            }
            printf("%d %d\n", i, s);
        }
    }
    if (n > 1) printf("%d %d\n", n, 1);
  
}
```

### 线性筛素数

埃氏筛法

$O(nloglogn)$

```c++
void get_primes(int n){
    for (int i = 2; i <= n; i++){
        if (!st[i]){
            primes[cnt++] = i;
            for(int j = i + i; j <= n; j += i) st[j] = true;
        }
    }
}
```

线性筛(n只会被它的最小质因子筛掉)

```c++
void get_primes(int n){
    for (int i = 2; i <= n; i++){
        if (!st[i]) primes[cnt++] = i;
        for (int j = 0; primes[j] <= n / i; j++){
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}
```

## 约数

### 试除法求约数（与试除法求质数类似）

```c++
#include<iostream>
#include<cstring>
#include<algorithm>
#include<vector>

using namespace std;

vector<int> get_devisors(int n){
    vector<int> res;
    for (int i = 1; i <= n / i; i++){
        if(n % i == 0){
            res.push_back(i);
            if(i != n / i) res.push_back(n / i);
        }
    }
    sort(res.begin(), res.end());
    return res;
}
```

### 约数个数

设$N=p_1^{\alpha_1}p_2^{\alpha_2}\cdots p_k^{\alpha_k}$，则约数个数为$(\alpha_1+1)(\alpha_2+1)\cdots(\alpha_k+1)$

```c++
#include<iostream>
#include<algorithm>
#include<unordered_map>

using namespace std;

typedef long long LL;
const int mod = 1e9 + 7;
int main(){
    int n;
    cin >> n;
    
    unordered_map<int, int> primes;
    while(n--){
        int x;
        cin >> x;
        for(int i = 2; i <= x / i; i++){
            while(x % i == 0){
                x /= i;
                primes[i]++;
            }
        }
        if (x > 1) primes[x]++;
    }
    LL res = 1;
    for(auto prime: primes) res = res * (prime.second + 1) % mod;
    cout << res << endl;
    return 0;
}
```



### 约数之和

设$N=p_1^{\alpha_1}p_2^{\alpha_2}\cdots p_k^{\alpha_k}$，则约数之和为$(p_1^0+p_1^1+p_1^2+\cdots+p_1^{\alpha_1})\cdots(p_k^0+p_k^1+p_k^2+\cdots+p_k^{\alpha_k})$

```c++
#include<iostream>
#include<algorithm>
#include<unordered_map>

using namespace std;

typedef long long LL;
const int mod = 1e9 + 7;
int main(){
    int n;
    cin >> n;
    
    unordered_map<int, int> primes;
    while(n--){
        int x;
        cin >> x;
        for(int i = 2; i <= x / i; i++){
            while(x % i == 0){
                x /= i;
                primes[i]++;
            }
        }
        if (x > 1) primes[x]++;
    }
    LL res = 1;
    for(auto prime: primes){
        int p = prime.first, a = prime.second;
        LL t = 1;
        while(a--) t = (t * p + 1) % mod; //这样做是因为 (p^0 + p^1 + p^2 + ... + p^a) 可以表示为 (p^0 + p^1(p^0 + p^1 + ... + p^(a-1)))
        res = res * t % mod;
    }
    
    cout << res << endl;
    return 0;
}
```

### 最大公约数（欧几里得算法）

$d|a, d|b, d|ax+by$，即d是a的约数，d是b的约数，那么d也是ax+by的约数

`(a, b) = (b, a mod b)`

```c++
#include<iostream>
using namespace std;

int gcd(int a, int b){
    return b ? gcd(b, a % b) : a; // 递归，当b为时，a与b的最大公约数就是a，否则按照上面的公式(a, b)=(n, a mod b)
}

int main(){
    int n;
    scanf("%d", &n);
    while(n--){
        int a, b;
        scanf("%d%d", &a, &b);
        printf("%d\n", gcd(a, b));
    }
    return 0;
}
```

## 欧拉函数

> $1$~$N$中与$N$互质的数的个数被称为欧拉函数，记作$\phi(N)$。
>
> 若在算数基本定理中，$N=p_1^{\alpha_1}p_2^{\alpha_2}\cdots p_m^{\alpha_m}$，则$\phi(N)=N\times \frac{p_1-1}{p_1}\times\frac{p_2-1}{p_2}\times\cdots\times\frac{p_m - 1}{p_m}$

证明（容斥原理）：

> 要求$1$~$N$中与$N$​互质的数的个数
>
> 1. 首先要从$1$~$N$中去掉$p_1, p_2, \cdots, p_m$的所有倍数
> 2. 加上所有$p_i \cdot p_j$​的倍数（因为前面减掉了多次）
> 3. 减去所有$p_i \cdot p_j \cdot p_k$的倍数
>
> $\phi(N) = N - \frac{N}{p_1}-\frac{N}{p_2}\cdots-\frac{N}{p_m}\\ +\frac{N}{p_1p_2} + \frac{N}{p_1p_3}\cdots \\ \frac{N}{p_1p_2p_3} - \frac{N}{p_1p_2p_4}\cdots\\ +\frac{N}{p_1p_2p_3p_4}\cdots$

```c++
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;
int n;

int main(){
    cin >> n;
    while(n--){
        int x, res;
        cin >> x;
        res = x;
        for (int i = 2; i <= x / i; i++){
            if (x % i == 0){
                while(x % i == 0){
                    x /= i;
                }
                res = res / i * (i - 1); // 乘除不能调转顺序，否则将导致整数上溢
            }
        }
        if (x != 1) res = res / x * (x - 1);
        cout << res << endl;
    }
    return 0;
}
```

### 筛法求欧拉函数之和

利用线性筛，在时间复杂度$O(n)$求出每个数的欧拉函数

```c++
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;

typedef long long LL;

const int N = 1000010;

int primes[N], cnt;
int phi[N];
bool st[N];

LL get_eulers(int n){
    phi[1] = 1; // 初始化必不可少
    for (int i = 2; i <= n; i++){
        if (!st[i]){
            primes[cnt++] = i;
            phi[i] = i - 1; // 情况1：如果某个数是质数，那么前i-1个数都和它互质
        }
        for (int j = 0; primes[j] <= n / i; j++){
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) {
                phi[primes[j] * i] = phi[i] * primes[j];
                // 情况2：这里pj实际上是i的一个质因子（因为i可以整除pj），根据欧拉函数公式，欧拉函数值和某个质因子出现的个数无关，那么这里实际上phi(pj*i)=phi(i)*pj(这里要乘一个pj的原因是N需要改变)
                break;
            }
            // 情况3：这时pj是pj*i的一个新的质因子，因此变为phi[i]*pj*(1-1/pj)，化简得到下面式子
            phi[primes[j] * i] = phi[i] * (primes[j] - 1);
        }
    }
    LL res = 0;
    for (int i = 1; i <= n; i++) res += phi[i];
    return res;
}

int main(){
    int n;
    cin >> n;
    cout << get_eulers(n) << endl;
    
    return 0;
}
```

### 欧拉定理

[初等数论笔记整理 - 知乎 (zhihu.com)](https://www.zhihu.com/column/c_1406644793112440832)

> 若$a$与$n$互质，则$a^{\phi(n)}\equiv 1\  (mod\ n)$

费马小定理

> 若存在整数$a$ ,质数$p$且`gcd(a,p)=1`,即二者互为质数，则有$a^{(p-1)}≡ 1\ (mod\ p)$。（$a^{p}≡ a\ (mod\ p)$）

## 快速幂

快速地求出$a^k\ mod\ p$的结果，$O(log\ k)$，其中$1\le a,p,k \le 10^9$

思路

> 先求出$a^{2^0}\ mod\ p$、$a^{2^1}\ mod\ p$、$a^{2^2}\ mod\ p$、$\cdots$、$a^{2^{log\ k}}\ mod\ p$​
>
> 然后将这些内容相乘，凑出$a^k\ mod\ p$（二进制优化）

```c++
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;
typedef long long LL;
int n;

int qmi(int a, int k, int p){
    int res = 1;
    while(k){
        if (k & 1) res = (LL) res * a % p;
        k >>= 1;
        a = (LL)a * a % p;
    }
    return res;
}

int main(){
    scanf("%d", &n);
    while(n--){
        int a, k, p;
        scanf("%d%d%d", &a, &k, &p);
        
        printf("%d\n", qmi(a, k, p));
    }
    return 0;
}
```

### 快速幂求逆元

> 若整数$b，m$互质，并且对于任意的整数$a$，如果满足$b|a$，则存在一个整数 $x$，使得 $\frac{a}{b}≡a×x(mod\ m)$，则称$x$为$b$的模$m$乘法逆元，记为 $b^{−1}\ (mod\ m)$。
>
> $b$存在乘法逆元的充要条件是$b$与模数$m$互质。当模数$m$为质数时，$b^{m−2}$即为 $b$​​的乘法逆元。
>
> 转化为：
> $$
> \frac{a}{b}\equiv a\cdot x\ (mod\ x)\\
> \frac{a}{b} \equiv a \cdot b^{-1}\ {mod\ m}\\
> b\cdot \frac{a}{b} \equiv b\cdot a b^{-1}\\
> a \equiv a\cdot b b^{-1}\\
> bb^{-1}\equiv 1\ mod \ m\\
> 根据费马小定理bb^{(p-2)}≡ 1\ (mod\ p)，我们要求的实际上就是b^{p-2}
> $$

```c++
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;
typedef long long LL;
int n;

int qmi(int a, int k, int p){
    int res = 1;
    while(k){
        if (k & 1) res = (LL) res * a % p;
        k >>= 1;
        a = (LL)a * a % p;
    }
    return res;
}

int main(){
    scanf("%d", &n);
    while(n--){
        int a, p;
        scanf("%d%d", &a, &p);
        int res = qmi(a, p - 2, p);
        if (a % p) printf("%d\n", res);
        else puts("impossible");
    }
    return 0;
}
```

## 扩展欧几里得算法

> **裴蜀定理**
>
> 对于任意正整数$a,b$，那么一定存在非零整数$x,y$，使得$ax+by=(a,b)$（a和b的最大公约数），且$(a,b)$是$a,b$​能凑出的最小的正整数。
>
> 扩展欧几里得算法就是给定$a,b$，就能得到$x,y$的值。

```c++
#include<iostream>
#include<algorithm>

using namespace std;

int exgcd(int a, int b, int &x, int &y){
    if(!b){
        x = 1, y = 0;// 这时候b已经等于0了，那么把b代入ax+by=a，得到a=1
        return a;
    }
    int d = exgcd(b, a % b, y, x); // 这里a和b已经交换位置，x与y也需要交换位置
    y -= a / b * x; // by+(a%b)x=d，by+(a-a/b)x=d，ax+b(y-a/b x)=d
    return d;
}

int main(){
    int n;
    scanf("%d", &n);
    
    while(n--){
        int a, b, x, y;
        scanf("%d%d", &a, &b);
        
        exgcd(a, b, x, y);
        printf("%d %d\n", x, y);
    }
    return 0;
}
```

求解线性同余方程

> $ax\equiv b\ (mod\ m)$等价于$ax=my+b$，即$ax+my^{'}=b$
>
> 要用扩展欧几里得算法来做，我们需要使得$(a,m)|b$，否则一定无解

```c++
#include<iostream>
#include<algorithm>

using namespace std;
typedef long long LL;

int exgcd(int a, int b, int &x, int &y){
    if(!b){
        x = 1, y = 0;// 这时候b已经等于0了，那么把b代入ax+by=a，得到a=1
        return a;
    }
    int d = exgcd(b, a % b, y, x); // 这里a和b已经交换位置，x与y也需要交换位置
    y -= a / b * x; // by+(a%b)x=d，by+(a-a/b)x=d，ax+b(y-a/b x)=d
    return d;
}

int main(){
    int n;
    scanf("%d", &n);
    
    while(n--){
        int a, b, m, x, y;
        scanf("%d%d%d", &a, &b, &m);
        
        int d = exgcd(a, m, x, y);
        if (b % d) puts("impossible");
        else printf("%d\n", (LL)x * (b / d) % m);
    }
    return 0;
}
```

## 中国剩余定理

> 给定两两互质的一组数$m_1,m_2,\cdots,m_k$，对于线性同余方程组$x\equiv a_i\ (mod\ m_i)$，设$M=m_1m_2\cdots m_k,M_i=\frac{M}{m_i},M^{-1}={M\mod m_i}^{-1}$，通解为$x=a_1M_1M_1^{-1}+a_2M_2M_2^{-1}+\cdots+a_kM_kM_k^{-1}$.



# 动态规划 DP

## 背包问题

### 01背包

每个物品最多只能用一次

 ![2c820d808f4f943b16d2df936038bbed_720](C:\Users\Lenovo\Documents\Tencent Files\2896425721\nt_qq\nt_data\Pic\2024-07\Thumb\2c820d808f4f943b16d2df936038bbed_720.png)

```c++
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;

const int N = 1010;

int n, m;
int v[N], w[N];
int f[N][N];

int main(){
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> v[i] >> w[i];
    
    for(int i = 1; i <= n; i++)
        for(int j = 0; j <= m; j++){
            f[i][j] = f[i - 1][j];
            if(j >= v[i]) f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]);
        }
    cout << f[n][m] << endl;
    return 0;
}
```

优化

```c++
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;

const int N = 1010;

int n, m;
int v[N], w[N];
int f[N];

int main(){
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> v[i] >> w[i];
    
    for(int i = 1; i <= n; i++)
        for(int j = m; j >= v[i]; j--){
            f[j] = max(f[j], f[j - v[i]] + w[i]);
        }
    cout << f[m] << endl;
    return 0;
}
```



### 完全背包

每个物品可以使用无限多次

![0a8d2c7ea53f15a8f74fa45fa9477ed0_720](C:\Users\Lenovo\Documents\Tencent Files\2896425721\nt_qq\nt_data\Pic\2024-07\Thumb\0a8d2c7ea53f15a8f74fa45fa9477ed0_720.png)

按照上面思路的朴素做法

```c++
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;

const int N = 1010;

int n, m;
int f[N][N];
int v[N], w[N];

int main(){
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> v[i] >> w[i];
    for (int i = 1; i <= n; i++){
        for (int j = 1; j <= m; j++){
            for (int k = 0; k * v[i] <= j; k++){
                f[i][j] = max(f[i][j], f[i - 1][j - k * v[i]] + w[i] * k);
            }
        }
    }
    
    cout << f[n][m] << endl;
    
    return 0;
}
```

优化思路：

```
f[i, j] = max(f[i - 1, j], f[i - 1, j - v] + w, f[i - 1, j - 2v] + 2w, f[i - 1, j - 3v] + 3w, ...)
f[i, j - v] = max(         f[i - 1, j - v],     f[i - 1, j - 2v] + w,  f[i - 1, j - 3v] + 2w, ...)
因此，f[i, j] = max(f[i - 1, j], f[i, j - v] + w)
```

```c++
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;

const int N = 1010;

int n, m;
int f[N][N];
int v[N], w[N];

int main(){
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> v[i] >> w[i];
    for (int i = 1; i <= n; i++){
        for (int j = 0; j <= m; j++){
            f[i][j] = f[i - 1][j];
            if (j >= v[i]) f[i][j] = max(f[i][j], f[i][j - v[i]] + w[i]);
        }
    }
    
    cout << f[n][m] << endl;
    
    return 0;
}
```

状态压缩

```c++
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;

const int N = 1010;

int n, m;
int f[N];
int v[N], w[N];

int main(){
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> v[i] >> w[i];
    for (int i = 1; i <= n; i++){
        for (int j = v[i]; j <= m; j++){
            f[j] = max(f[j], f[j - v[i]] + w[i]);
        }
    }
    
    cout << f[m] << endl;
    
    return 0;
}
```



### 多重背包

每个物品可以使用$s_i$次

朴素写法

```C++
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;

const int N = 110;
int f[N][N];
int n, m;
int v[N], w[N], s[N];

int main(){
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> v[i] >> w[i] >> s[i];
    
    for (int i = 1; i <= n; i++){
        for (int j = 1; j <= m; j++){
            for (int k = 0; k * v[i] <= j && k < s[i]; k++){
                f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k);
            }
        }
    }
    cout << f[n][m] << endl;
    return 0;
}
```

优化思路，这里不能使用和完全背包一样的优化方法，原因如下：

```
f[i,j]=max(f[i-1,j],f[i-1,j-v]+w,f[i-1,j-2v]+2w,...,f[i-1,j-sv]+sw)
f[i,j-v]=max(       f[i-1,j-v],  f[i-1,j-2v]+w,..., f[i-1,j-sv]+(s-1)w, f[i-1,j-(s+1)v]+sw)
```

优化思路如下：

```
特殊的，考虑s=1023
分割为1,2,4,8，...，512
每一个分割只能选一个

对于一般的s，我们取1,2,4，8，...，2^k，c，这里的2^k是1+2+4+...+2^k<s最大的一个k，最后补一个c，这样可以得到0~s的任意一个数

拆分完成后，把每一个拆分看做一个新的物品，然后进行一次01背包
```

```c++
#include<iostream>
#include<algorithm>

using namespace std;

const int N = 25000, M = 2010;

int n, m;
int v[N], w[N];
int f[N];


int main(){
    cin >> n >> m;
    
    int cnt = 0;
    for (int i = 1; i <= n; i++){
        int a, b, s;
        cin >> a >> b >> s;
        int k = 1;
        while(k <= s){
            cnt++;
            v[cnt] = a * k;
            w[cnt] = b * k;
            s -= k;
            k *= 2;
        }
        if (s > 0){
            cnt++;
            v[cnt] = a * s;
            w[cnt] = b * s;
        }
    }
    n = cnt;
    
    for (int i = 1; i <= n; i++){
        for (int j = m; j >= v[i]; j--){
            f[j] = max(f[j], f[j - v[i]] + w[i]);
        }
    }
    cout << f[m] << endl;
    return 0;
}
```



### 分组背包

有不同组别的物品，每个组别只能选取一种物品。

![83046feac4191e77eacf37359d268a76_720](C:\Users\Lenovo\Documents\Tencent Files\2896425721\nt_qq\nt_data\Pic\2024-07\Thumb\83046feac4191e77eacf37359d268a76_720.png)

```c++
#include<iostream>
#include<algorithm>

using namespace std;

const int N = 110;

int n, m;
int v[N][N], w[N][N], s[N];
int f[N];

int main(){
    cin >> n >> m;
    
    for (int i = 1; i <= n; i++){
        cin >> s[i];
        for (int j = 1; j <= s[i]; j++){
            cin >> v[i][j] >> w[i][j];
        }
    }
    for (int i = 1; i <= n; i++){
        for (int j = m; j >= 0; j--){
            for (int k = 1; k <= s[i]; k++)
                if (j >= v[i][k]) f[j] = max(f[j], f[j - v[i][k]] + w[i][k]);
        }
    }
    cout << f[m] << endl;
    return 0;
}
```



## 线性DP

数字三角形

![image-20240711134637052](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20240711134637052.png)

```c++
#include <iostream>
#include <cstring>
using namespace std;
const int N = 510,INF = 1e9;
int n;
int a[N][N],f[N][N];
int main () {
    cin >> n;
    for (int i = 1;i <= n;i++) {
        for (int j = 1;j <= i;j++) cin >> a[i][j];
    }
    for (int i = 0;i <= n;i++) {
        for (int j = 0;j <= i + 1;j++) {
            f[i][j] = -INF;
        }
    }
    f[1][1] = a[1][1];
    for (int i = 2;i <= n;i++) {
        for (int j = 1;j <= i;j++) {
            f[i][j] = max (f[i - 1][j - 1],f[i - 1][j]) + a[i][j];
        }
    }
    int ans = -INF;
    for (int i = 1;i <= n;i++) ans = max (ans,f[n][i]);
    cout << ans << endl;
    return 0;
}

```

最长上升子序列

![image-20240711151054699](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20240711151054699.png)

```c++
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;

const int N = 1010;
int f[N], a[N];
int n;

int main(){
    cin >> n;
    for(int i = 1; i <= n; i++) cin >> a[i];
    
    for (int i = 1; i <= n; i++){
        f[i] = 1;
        for (int j = 1; j < i; j++){
            if (a[j] < a[i]) f[i] = max(f[i], f[j] + 1);
        }
    }
    int res = 0;
    for (int i = 1; i <= n; i++) res = max(res, f[i]);
    cout << res << endl;
    return 0;
}
```

当数据量大时，可以使用二分+贪心来优化：

```c++
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;

const int N = 100010;
int n;
int q[N], a[N];


int main(){
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i];
    int len = 0;
    q[0] = 2e9;
    for (int i = 1; i <= n; i++){
        int l = 0, r = len;
        while(l < r){
            int mid = l + r + 1 >> 1;
            if (q[mid] < a[i]) l = mid;
            else r = mid - 1;
        }
        len = max(len, r + 1);
        q[r + 1] = a[i];
    }
    cout << len << endl;
    return 0;
}
```



最长公共子序列

![image-20240711155436780](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20240711155436780.png)

这里用`f[i-1,j]`来表示01是有重复的，因为`f[i-1,j]`实际上并不一定包含j，10同理，但是因为这里求的是最大值，因此实际上用`f[i-1, j]`只会导致有重复，并不会导致结果的不正确。00的情况实际上可以被后面三种情况涵盖，也可以不要。

```c++
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;

const int N = 1010;
int n, m;
char a[N], b[N];
int f[N][N];

int main(){
    cin >> n >> m;
    scanf("%s%s", a + 1, b + 1);
    for (int i = 1; i <= n; i++){
        for (int j = 1; j <= m; j++){
            f[i][j] = max(f[i - 1][j], f[i][j - 1]);
            if (a[i] == b[j]) f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1);
        }
    }
    cout << f[n][m] << endl;
    return 0;
}
```

最短编辑距离

把A中的前i个字母变成B中的前j个字母的最小距离

```c++
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;

const int N = 1010;
int n, m;
char a[N], b[N];
int f[N][N];

int main(){
    cin >> n;
    scanf("%s", a + 1);
    cin >> m;
    scanf("%s", b + 1);
    for (int i = 0; i <= m; i++) f[0][i] = i;
    for (int j = 0; j <= n; j++) f[j][0] = j;
    
    for (int i = 1; i <= n; i++){
        for (int j = 1; j <= m; j++){
            f[i][j] = min(f[i - 1][j], f[i][j - 1]) + 1; // 两种情况，一种是前i-1个字母已经和前j个字母一样了，我要变成和前i-1个字母一样，需要删掉一个字母
                                                         // 第二种情况是，当前i个字母和前j-1个字母一样，那么我们要添加一个字母
            f[i][j] = min(f[i][j], f[i - 1][j - 1] + (a[i] != b[j])); // 需不需要更改，就看这一对字母是不是相等的，如果相等的就不需要改，否则就要+1
        }
    }
    cout << f[n][m];
    return 0;
}
```



## 区间DP

![image-20240711190234512](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20240711190234512.png)

```c++
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;

const int N = 310;
int n;
int s[N], f[N][N]; // 将第i堆到第j堆石子合并所需要的最小代价

int main(){
    cin >> n;
    memset(f, 0x3f, sizeof f);
    for (int i = 1; i <= n; i++){
        cin >> s[i];
        s[i] += s[i - 1]; // 前缀和，方便计算
        f[i][i] = 0;
    }
    
    for (int len = 2; len <= n; len++){
        for (int l = 1; l + len - 1 <= n; l++){
            int r = l + len - 1;
            for (int k = 1; k < r; k++)
                f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1]);
        }
    }
    cout << f[1][n] << endl;
    return 0;
}
```



## 计数类DP

整数划分

思路1

使用前i个数，表示总和为j的数量

```c++
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;

const int N = 1010, mod = 1e9 + 7;
int n;
int f[N];

int main(){
    cin >>n;
    f[0] = 1;
    for (int i = 1; i <= n; i++)
        for (int j = i; j <= n; j++)
            f[j] = (f[j] + f[j - i]) % mod;
    cout << f[n] << endl;
    return 0;
}
```

思路2

![image-20240711194320147](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20240711194320147.png)

对于最小值是1的一半，我们只需要将某个1减去

对于最小值大于1的一半，我们则可以把每个数减去一个1

```c++
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;

const int N = 1010, mod = 1e9 + 7;

int n;
int f[N][N];

int main(){
    cin >> n;
    f[0][0] = 1;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= i; j++)
            f[i][j] = (f[i - 1][j - 1] + f[i - j][j]) % mod;
   	int res = 0;
    for (int i = 1; i <= n; i++) res = (res + f[n][i]) % mod;
    
    cout << res << endl;
    
    return 0;
}
```



## 数位统计DP

计数问题

```
分情况讨论

[a, b] 0~9
count(n, x) 该函数表示1~n中x出现的次数
count(b, x) - count(a, x) 就可以得到最终每个数字在[a, b]中出现的次数。
```

![294.jpg](https://cdn.acwing.com/media/article/image/2019/10/27/3937_fcd1d744f8-294.jpg)

![295.jpg](https://cdn.acwing.com/media/article/image/2019/10/27/3937_027d9fc0f8-295.jpg)

![296.jpg](https://cdn.acwing.com/media/article/image/2019/10/27/3937_068e2710f8-296.jpg)

![297.jpg](https://cdn.acwing.com/media/article/image/2019/10/27/3937_1b42ad5cf8-297.jpg)

![298.jpg](https://cdn.acwing.com/media/article/image/2019/10/27/3937_1697cd50f8-298.jpg)

```c++
#include <iostream>
#include <vector>

using namespace std;

int base[10];
int f[10][10];
int g[10][10];

void init()
{
    base[0] = 1;
    for(int i = 1 ; i <= 9 ; i++) base[i] = base[i-1]*10;

    //从00……0 - 99……9 的各位数字有多少个，其中i为数字个数（包含前导零）
    for(int i = 0 ; i <= 9 ; i++) f[1][i] = 1;
    for(int i = 2 ; i <= 9 ; i++)
        for(int j = 0 ; j <= 9 ; j++)
            f[i][j] = f[i-1][j]*10 + base[i-1];

    //从1 - 99……9 的各位数字有多少个，其中i为数字个数（不包含前导零）
    for(int i = 1 ; i <= 9 ; i++) g[1][i] = 1;//循环从1开始
    for(int i = 2 ; i <= 9 ; i++) {
        g[i][0] = g[i-1][0] + f[i-1][0]*9;
        for(int j = 1 ; j <= 9 ; j++)
            g[i][j] = g[i-1][j] + f[i-1][j]*9 + base[i-1];
    }
}

vector<int> dp(int n)
{
    vector<int> ans(10,0); //记录答案
    if(n<=0) return ans; //边界条件

    vector<int> nums;
    while(n) nums.push_back(n%10), n/=10;

    vector<int> last(10,0); //记录前缀中各个数字个数

    //统计1 - 99……9(n-1个9)里面各个数字有多少个
    for(int i = 0 ; i <= 9 ; i++) ans[i] = g[nums.size()-1][i];
    //统计大于10……0(n-1个0) 的树里各个数字有多少个
    for(int i = nums.size()-1 ; i >=0 ; i--) {
        //循环变量i可以表示剩下的数字有多少个
        int x = nums[i];
        for(int j = i==nums.size()-1 ; j < x ; j++) { //第一次循环不能有0
            //前缀部分
            for(int k = 0 ; k <= 9 ; k++)
                ans[k] += last[k] * base[i];
            //当前位置部分
            ans[j] += base[i];
            //后缀部分
            for(int k = 0 ; k <= 9 ; k++)
                ans[k] += f[i][k];
        }
        //更新前缀计数器
        last[x] ++;

        //统计叶子节点（这个数本身）
        if(!i) for(int k = 0 ; k <= 9 ; k++) ans[k] += last[k];
    }
    return ans;
}

vector<int> ask(int a, int b)
{
    auto x = dp(b);
    auto y = dp(a-1);
    vector<int> ans;
    for(int i = 0 ; i <= 9 ; i++) ans.push_back(x[i]-y[i]);
    return ans;
}

void print(vector<int> ans)
{
    for(auto x:ans) printf("%d ",x);
    puts("");
}

bool check(int x)
{
    auto t = ask(x,x);
    vector<int> cnt(10,0);
    while(x) cnt[x%10]++,x/=10;
    for(int i = 0 ; i <= 9 ; i++)
        if(cnt[i] != t[i])
            return false;
    return true;
}

int main()
{
    init();

    //这里是一个DEBUG函数
    // for(int i = 1 ; i <= 1000000 ; i*=10) {
    //     if(!check(i))
    //         printf("ERROR:%d\n",i);
    // }

    int a,b;
    while(cin >> a >> b, a||b) {
        if(a>b) swap(a,b);
        auto t = ask(a,b);
        print(t);
    }

    return 0;
}
```



## 状态压缩DP

![image-20240711203753310](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20240711203753310.png)



## 树形DP



## 记忆化搜索



# 贪心

## 区间问题

### 区间选点(最大不相交区间数量)

```
1.将每个区间按右端点从小到大排序
2.从前往后枚举每个区间（每次选最右侧的点）
  如果当前区间已经包含点，则直接pass
  否则，选择当前区间的右端点。
```

```c++
#include<iostream>
#include<vector>
#include<cstring>
#include<algorithm>

using namespace std;

const int N = 100010;
typedef pair<int, int> PII;

PII a[N];
int n;

int main(){
    cin >> n;
    for (int i = 0; i < n; i++){
        int x, y;
        cin >> x >> y;
        a[i] = {y, x};
    }
    
    sort(a, a + n);
    
    int res = 0, ed = -2e9;
    
    for (int i = 0; i < n; i++){
        if (a[i].second > ed){
            res++;
            ed = a[i].first;
        }
    }
    cout << res << endl;
    return 0;
}
```

### 区间分组

```
1.将所有区间按左端点从小到大排序
2.从前往后处理每个区间
  判断能否将其放到某个现有的组中（判断L[i] > Max_r，这样才符合要求）
    （1）如果不存在这样的组，则开一个新的组
    （2）如果存在这样的组，将其放进去，并更新当前组的Max_r
    
```

```c++
#include<iostream>
#include<algorithm>
#include<queue>

using namespace std;

const int N = 100010;

int n;
struct Range{
    int l, r;
    bool operator< (const Range &W)const{
        return l < W.l;
    }
}range[N];

int main(){
    scanf("%d", &n);
    for (int i = 0;i < n; i++){
        int l, r;
        scanf("%d%d", &l, &r);
        range[i] = {l, r};
    }
    sort(range, range + n);
    
    priority_queue<int, vector<int>, greater<int>> heap;
    for (int i = 0; i < n; i++){
        auto r = range[i];
        if (heap.empty() || heap.top() >= r.l) heap.push(r.r);
        else{
            int t = heap.top();
            heap.pop();
            heap.push(r.r);
        }
    }
    
    printf("%d", heap.size());
    return 0;
}
```



### 区间覆盖

```
1.将所有端点按左端点从小到大排序
2.从前往后一次枚举每个区间，在所有能覆盖start的区间当中，选择右端点最大的区间，然后将start更新成右端点的最大值
```

```c++
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;
const int N = 100010;
int n;
int st, ed;
struct Range{
    int l, r;
    bool operator< (const Range &W)const{
        return l < W.l;
    }
}range[N];

int main(){
    scanf("%d%d", &st, &ed);
    scanf("%d", &n);
    for (int i = 0; i < n; i++){
        int l, r;
        scanf("%d%d", &l, &r);
        range[i] = {l, r};
    }
    sort(range, range + n);
    bool success = false;
    int res = 0;
    for (int i = 0; i < n; i++){
        int j = i, r = -2e9;
        while(j < n && range[j].l <= st){
            r = max(r, range[j].r);
            j++;
        }
        
        if (r < st){
            res = -1;
            break;
        }
        res++;
        if (r >= ed){
            success = true;
            break;
        }
        st = r;
        i = j - 1;
    }
    if (!success) res = -1;
    printf("%d", res);
    return 0;
}
```



## Huffman树

```c++
#include<iostream>
#include<queue>
#include<algorithm>

using namespace std;
const int N = 10010;
int n;
int a[N];

int main(){
    cin >> n;
    priority_queue<int, vector<int>, greater<int>> queue;
    for (int i = 0; i < n; i++){
        int x;
        scanf("%d", &x);
        queue.push(x);
    }
    int res = 0;
    while(queue.size() > 1){
        int x, y;
        x = queue.top();
        queue.pop();
        y = queue.top();
        queue.pop();
        res += (x + y);
        queue.push(x + y);
    }
    printf("%d", res);
    return 0;
}
```

## 排序不等式

打水问题，要让等待时间最小，那么让用时最短的人先打水

```c++
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;
const int N = 100010;
typedef long long LL;
int a[N];
int n;

int main(){
    cin >> n;
    for (int i = 0; i < n; i++) cin >> a[i];
    sort(a, a + n);
    LL res = 0;
    for (int i = 0; i < n; i++) res += a[i] * (n -i -1);
    cout << res << endl;
    return 0;
}
```



## 绝对值不等式

![image-20240712132359270](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20240712132359270.png)

```c++
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;
const int N = 100010;
typedef long long LL;
int a[N];
int n;

int main(){
    cin >> n;
    for (int i = 0; i < n; i++) cin >> a[i];
    sort(a, a + n);
    int mid = n / 2;
    LL res;
    for (int i = 0; i < n; i++) res += abs(a[i] - a[mid]);
    cout << res << endl;
    return 0;
}
```
